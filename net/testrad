#!/usr/bin/env bash
# testrad -- automates RADIUS testing between domains

. lib.bash || exit

declare -- self via save_chain
declare -A name user pass host port secret eap _alias_
declare -- _host _port _secret _eap _phase2 _outer _user _pass
declare -- _tlscert _tlskey _tlsca
declare -a _tlsopt
declare -a phase1_opts
declare -a _ecfg_full _ecfg_extra
declare -A _ecfg_values _ecfg_seen

eapol_bin="eapol_test"

# parse arguments

while (( $# )); do
	if [[ ! $self ]]; then
		debug "accepting arg '$1' as self & via"
		self=$1
		via=$self
	else
		debug "parsing arg '$1', next '$2'"
		case ${1#--} in
		# RADIUS server
		'via')		via=$2; shift;;
		'host')		_host=$2; shift;;
		'port')		_port=$2; shift;;
		'secret')	_secret=$2; shift;;
		'-x')		eapol_bin=$2; shift;;
		'-o')		_ecfg_extra+=("$2"); shift;;
		'-O')		save_chain=$2; shift;;
		'show-config')	dump_config=1; shift;;
		# basic or inner mechanism
		'phase2')	_mech=$2; shift;;
		'mech')		_mech=$2; shift;;
		'using')	_mech=$2; shift;;
		# outer EAP mechanism
		'phase1')	_eap=$2; shift;;
		'eap')		_eap=$2; shift;;
		'inside')	_eap=$2; shift;;
		# main (inner) identity
		'user')		_user=$2; : ${_pass:="-"}; shift;;
		'login')	_user=$2; : ${_pass:="-"}; shift;;
		'inner-user')	_user=$2; : ${_pass:="-"}; shift;;
		'inner-login')	_user=$2; : ${_pass:="-"}; shift;;
		'pass')		_pass=$2; shift;;
		'cert')		_tlscert=$2; shift;;
		'key')		_tlskey=$2; shift;;
		'ca'|'ca-cert')	_tlsca=$2; shift;;
		'tls')		_tlsopt+=("$2"); shift;;
		# anonymous (outer) identity
		'anon')		_outer=$2; shift;;
		'outer')	_outer=$2; shift;;
		'outer-user')	_outer=$2; shift;;
		'outer-login')	_outer=$2; shift;;
		# misc eapol options
		'subject-match')
			_ecfg_extra+=("subject_match=\"$2\""); shift;;
		'altsubject-match')
			_ecfg_extra+=("altsubject_match=\"$2\""); shift;;
		'domain-match')
			_ecfg_extra+=("domain_match=\"$2\""); shift;;
		'domain-suffix-match')
			_ecfg_extra+=("domain_suffix_match=\"$2\""); shift;;
		# etc.
		*)		err "bad arg: \"$1\"";;
		esac
	fi
	shift
done

# check for necessary tools

have 'radtest' || err "missing 'radtest' binary"
have "$eapol_bin" || err "missing '$eapol_bin' binary"

[[ $self ]] || err "missing realm argument"

(( !errors )) || exit

# parse config

lib::find_file config_file= ~/lib/testrad.conf.sh config:testrad.conf.sh

debug "loading hosts from '$config_file'"

. "$config_file" || die "could not load configuration"

while val=${_alias_[$self]}; [[ $val ]]; do
	debug "conf alias (\$self) \"$self\" -> \"$val\""
	self=$val
done

while val=${_alias_[$via]}; [[ $val ]]; do
	debug "conf alias (\$via) \"$via\" -> \"$val\""
	via=$val
done

debug "self \"$self\", via \"$via\""

# load parameters

[[ $_user ]]	|| _user=${user[$self]}
[[ $_pass ]]	|| _pass=${pass[$self]}
[[ $_eap ]]	|| _eap=${eap[$self]}
[[ $_host ]]	|| _host=${host[$via]}
[[ $_port ]]	|| _port=${port[$via]:-1812}
[[ $_secret ]]	|| _secret=${secret[$via]}
[[ $_outer ]]	|| _outer=${_user}

_eap=${_eap^^}

if [[ $_eap == PEAP ]]; then
	_mech=${_mech:-eap-mschapv2}
else
	_mech=${_mech:-mschapv2}
fi

[[ $_user ]]	|| err "missing username for '$self'"
if [[ $_pass == "-" ]]; then
	read -s -p "password for '$_user': " _pass; echo
fi
[[ $_pass ]]	|| err "missing password for '$self'"
[[ $_host ]]	|| err "missing RADIUS server for '$via'"
[[ $_secret ]]	|| err "missing RADIUS secret for '$via'"

if [[ $_outer == "@" ]]; then
	_outer+=${_user#*@}
fi

case $_mech in
	'pap')		_phase2='PAP';;
	'chap')		_phase2='CHAP';;
	'mschap')	_phase2='MSCHAP';;
	'mschapv2')	_phase2='MSCHAPV2';;
	'eap-gtc')	_phase2='EAP-GTC';;
	'eap-md5')	_phase2='EAP-MD5';;
	'eap-mschap')	_phase2='EAP-MSCHAP';;
	'eap-mschapv2')	_phase2='EAP-MSCHAPV2';;
	# in case I ever try to make this nonsense work
	'eap-pap')	die "PAP is not an EAP mechanism";;
	'eap-chap')	die "CHAP is not an EAP mechanism";;
	*)		err "unknown mechanism '$_mech'";;
esac

if [[ ! $_eap && $_mech != @(pap|chap|mschap|eap-md5) ]]; then
	die "radtest does not support the '$_mech' mechanism"
fi

if [[ $_eap == TLS ]]; then
	if [[ ! $_tlscert ]]; then
		err "missing certificate for EAP-$_eap ('cert' option)"
	elif [[ ! -f $_tlscert ]]; then
		err "certificate '$_tlscert' does not exist"
	fi

	if [[ ! $_tlskey ]]; then
		err "missing private key for EAP-$_eap ('key' option)"
	elif [[ ! -f $_tlskey ]]; then
		err "key file '$_tlskey' does not exist"
	fi
fi

if [[ $_eap == @(PEAP|TLS|TTLS) ]]; then
	for opt in "${_tlsopt[@]}"; do
		case $opt in
		'no-v1.0')	phase1_opts+=("tls_disable_tlsv1_0=1");;
		'no-v1.1')	phase1_opts+=("tls_disable_tlsv1_1=1");;
		'no-v1.2')	phase1_opts+=("tls_disable_tlsv1_2=1");;
		'tls_'*)	phase1_opts+=("$opt");;
		*)		err "unknown TLS option '$opt'";;
		esac
	done
fi

(( ! errors )) || exit

log "account: \"$_user\""
debug "password: \"$_pass\""
log "home server: ${name[$self]} (${host[$self]:-none})"
if [[ "$self" != "$via" ]]; then
	log "proxy via: ${name[$via]} ($_host)"
fi

if [[ $_eap && $_eap != NONE ]]; then
	# base options
	_ecfg_full=(
		"ssid=\"eduroam\""
		"key_mgmt=WPA-EAP"
		"eap=$_eap"
	)
	if [[ ${phase1_opts[*]} ]]; then
		_ecfg_full+=("phase1=\"${phase1_opts[*]}\"")
	fi

	case $_eap,$_phase2 in
	PEAP,EAP-MSCHAP)
		err "EAP-$_eap does not support the '$_phase2' method";;
	PEAP,EAP-*)
		_ecfg_full+=("phase2=\"auth=${_phase2#EAP-}\"");;
	PEAP,*)
		err "EAP-$_eap can only transport EAP methods";;
	TTLS,EAP-*)
		_ecfg_full+=("phase2=\"autheap=${_phase2#EAP-}\"");;
	TTLS,*)
		_ecfg_full+=("phase2=\"auth=${_phase2}\"");;
	esac

	# credentials
	_ecfg_full+=("identity=\"$_user\"")
	_ecfg_full+=("password=\"$_pass\"")
	if [[ $_outer ]]; then
		_ecfg_full+=("anonymous_identity=\"$_outer\"")
	fi
	if [[ $_tlsca ]]; then
		_ecfg_full+=("ca_cert=\"$_tlsca\"")
	fi
	if [[ $_tlscert ]]; then
		_ecfg_full+=("client_cert=\"$_tlscert\"")
	fi
	if [[ $_tlskey ]]; then
		_ecfg_full+=("private_key=\"$_tlskey\"")
	fi

	# user-supplied settings
	for opt in "${_ecfg_extra[@]}"; do
		case $opt in
		'anonymous_identity='*)
			err "'$opt': use 'outer-user ...' to set the anonymous identity";;
		'eap='*)
			err "'$opt': use 'eap ...' to set the outer EAP method";;
		'identity='*)
			err "'$opt': use 'user ...' to set the auth identity";;
		'phase2='*)
			err "'$opt': use 'phase2 ...' to set the inner EAP method";;
		?*'='*)
			_ecfg_full+=("$opt");;
		*)
			err "supplicant option '$opt' given without value";;
		esac
	done
	(( ! errors )) || exit

	# if option given multiple times, the last value takes priority
	for opt in "${_ecfg_full[@]}"; do
		k=${opt%%=*}
		v=${opt#*=}
		_ecfg_values["$k"]=$v
	done

	log "mechanism: EAP-$_eap (outer), $_phase2 (inner)"
	if [[ "$_outer" != "$_user" ]]; then
		log "anonymous identity: \"$_outer\""
	fi

	# generate the eapol_test config
	wd=$(mktemp -d /tmp/testrad.XXXXXXXX)
	conf="$wd/eapol_test.conf"
	{
		echo "network={"
		for opt in "${_ecfg_full[@]}"; do
			k=${opt%%=*}
			v=${_ecfg_values["$k"]}
			if (( _ecfg_seen["$k"]++ )); then
				continue
			fi
			echo "  $k=$v"
		done
		echo "}"
	} > "$conf"
	(( ! errors )) || exit

	cmd=($eapol_bin -c "$conf" -a "$_host" -p "$_port" -s "$_secret" -t 5
			-M "22:44:66:42:42:42" -C "testrad+eapol_test")

	if [[ $save_chain ]]; then
		cmd+=(-o "$save_chain")
	fi

	if (( dump_config )); then
		notice "dumping generated config and exiting"
		cmd=(cat "$conf")
	fi
else
	log "mechanism: $_phase2 (direct)"
	if [[ "$_outer" != "$_user" ]]; then
		die "anonymous identity \"$_outer\" not supported without EAP"
	fi
	cmd=(radtest -t "$_mech" "$_user" "$_pass" "$_host:$_port" 0 "$_secret")
fi

echo "+ ${cmd[*]}"
if "${cmd[@]}"; then
	r=0
	log "test successful"
else
	r=$?
	err "test failed ($cmd returned $r)"
fi

if [[ -s $save_chain ]]; then
	log "server certificate chain saved to '$save_chain'"
elif [[ $save_chain ]]; then
	err "did not obtain server certificate chain"
fi

if [[ $wd == /tmp/testrad.* ]]; then
	rm -rf "$wd"
fi

exit $r

#!/usr/bin/env perl
use Net::LDAP;

my $err = 0;

my %F = (
	bold	=> "\e[1m",
	red	=> "\e[31m",
	green	=> "\e[32m",
	reset	=> "\e[m",
);

%F = map {$_ => ""} keys %f if !-t 0;

sub uniq (@) { my %seen = (); grep { not $seen{$_}++ } @_; }

sub _tree_status {
	my ($tree, $status, $note) = @_;
	my %C = (
		ok => "green",
		desynced => "red",
	);
	my $C = $C{$status};
	my $str = "tree '$tree' $F{bold}$F{$C}$status$F{reset}$F{$C}, $note$F{reset}";
	if ($status eq "ok") { print "$str\n"; } else { warn "$str\n"; ++$err; }
}

sub _err {
	my ($msg) = @_;
	warn "$F{bold}$F{red}error$F{reset}: $msg\n";
	++$err;
}

sub _err_while {
	my ($head, $tail) = @_;
	warn "$F{bold}$F{red}error$F{reset}$F{red} $head$F{reset} $tail\n";
	++$err;
}

my @domains = qw[ cluenet.org nullroute.eu.org ];

my @cluster = qw[ ];

my @trees = qw[ cn=config ];

push @cluster,
	map {[split / /]->[3]}
	grep {chomp||1}
	map {`dig +short _ldap._tcp.$_. srv`}
	@domains;

push @trees,
	map {join ",", map {"dc=$_"} split /\./, $_}
	@domains;

my %conns;
my %csns;
my %rcsns;
my $hosts = 0;

for my $host (uniq @cluster) {
	print "querying '$host'\n";
	my $conn = Net::LDAP->new($host);
	if (!$conn) {
		_err_while("connecting", "to '$host'");
		next;
	}
	$conn->bind;
	for my $base (@trees) {
		my $res = $conn->search(
				base => $base,
				scope => "base",
				filter => q(objectClass=*),
				attrs => ["contextCSN"]);
		if ($res->is_error) {
			_err_while("looking up CSN", "for $base: ".$res->error_name);
			next;
		}
		my @csn = 
			map {$_->[0]}
			sort {$a->[1] cmp $b->[1]}
			map {[$_, (split(/#/, $_))[2]]}
			($res->entries)[0]->get_value("contextCSN");
		my $csn = join(" ", @csn);
		$csns{$base}{$host} = $csn;
		push @{$rcsns{$base}{$csn}}, $host;
		++$hosts;
	}
	$conn->unbind;
}

if ($hosts == 0) {
	_err("no reachable replicas!");
	exit $err;
} elsif ($hosts == 1) {
	_err("only one reachable replica!");
}

for my $base (@trees) {
	my %csn = %{$csns{$base}};
	my %rcsn = %{$rcsns{$base}};
	my @groups = keys %rcsn;
	if (@groups == 1) {
		_tree_status($base, "ok", "all CSNs identical");
		print "  host='$_'\n" for @{$rcsn{$groups[0]}};
		print "  csn='$_'\n" for split(" ", $groups[0]);
	} else {
		my $num = @groups;
		_tree_status($base, "desynced", "$num different CSNs");
		for my $csn (@groups) {
			warn "  host='$_'\n" for @{$rcsn{$csn}};
			warn "  csn='$_'\n" for split(" ", $csn);
			warn "  ---\n" if --$num;
		}
		++$err;
	}
}

exit $err;

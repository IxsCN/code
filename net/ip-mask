#!/usr/bin/env python
import sys
from ipaddress import *
from nullroute import Core

IPV6_MCAST_SCOPES = {
    0x0: "reserved",
    0x1: "interface-local",
    0x2: "link-local",
    0x4: "admin-local",
    0x5: "site-local",
    0x8: "organization-local",
    0xe: "global",
    0xf: "reserved",
}

def nprint(k, *v):
    width = 12
    print("\033[33m%*s\033[m" % (width, k), *v)

def addr2props(addr):
    kind = "unknown"
    misc = []
    if addr.version == 6:
        if addr.is_loopback:
            kind = "loopback"
        elif addr.is_unspecified:
            kind = "unspecified"
        elif addr.teredo:
            kind = "Teredo"
            relay, v4addr = addr.teredo
            misc.append(("relay host", addr.teredo[0]))
            misc.append(("v4 address", addr.teredo[1]))
        elif addr.sixtofour:
            kind = "6to4"
            misc.append(("v4 address", addr.sixtofour))
        elif addr.ipv4_mapped:
            kind = "IPv4-mapped"
            misc.append(("v4 address", addr.ipv4_mapped))
        elif addr.is_link_local:
            kind = "link-local"
        elif addr.is_site_local:
            kind = "site-local"
        elif addr.is_multicast:
            kind = "multicast"
            flags = (addr.packed[1] >> 4) & 0xF
            scope = addr.packed[1] & 0xF
            scope = IPV6_MCAST_SCOPES.get(scope, "invalid scope")
            misc.append(("scope", scope))
        elif addr in IPv6Network("fc00::/7"):
            kind = "unique local address"
        elif addr in IPv6Network("::/96"):
            kind = "IPv4-compatible"
            misc.append(("v4 address", IPv4Address(addr.packed[12:])))
        elif addr.is_reserved:
            kind = "reserved"
    elif addr.version == 4:
        pass
    return kind, misc

def show_addr(addr):
    nprint("address", addr)
    if addr.version == 6:
        nprint("->", addr.exploded)
    kind, misc = addr2props(addr)
    nprint("type", kind)
    for k, v in misc:
        nprint(k, v)

def show_net(net):
    nprint("network", net)
    if addr.version == 4:
        nprint("netmask", net.netmask, "(%d addresses)" % net.num_addresses)
    else:
        nprint("netmask", net.netmask.exploded)
    nprint("first addr", net.network_address.exploded)
    nprint("last addr", net.broadcast_address.exploded)
    next_net = ip_network("%s/%s" % (net.broadcast_address + 1, net.prefixlen))
    nprint("next net", next_net)

try:
    arg = sys.argv[1]
    if arg.startswith("/"):
        plen = int(arg[1:])
        if plen < 0:
            Core.die("prefix length must be positive")
        elif plen > 128:
            Core.die("prefix length too large for any family")

        nprint("prefix", "/%d" % plen)
        if plen <= 32:
            net = ip_network("0.0.0.0/%d" % plen)
            nprint("v4 netmask", net.netmask, "(%d addresses)" % net.num_addresses)
        net = ip_network("::/%d" % plen)
        nprint("v6 netmask", net.netmask.exploded)
    elif "/" in arg:
        addr = ip_interface(arg)
        show_addr(addr)
        print()
        show_net(addr.network)
    else:
        addr = ip_address(arg)
        if addr.version == 4 and addr._is_valid_netmask(arg):
            net = ip_network("0.0.0.0/%s" % arg)
            nprint("netmask", net.netmask)
            nprint("prefix", "/%d" % net.prefixlen)
            nprint("size", net.num_addresses)
        else:
            show_addr(addr)
except IndexError:
    Core.die("not enough arguments")
except ValueError as e:
    Core.die(str(e))

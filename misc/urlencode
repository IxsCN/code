#!/usr/bin/env perl
use warnings;
use strict;
use Getopt::Long qw(:config bundling no_ignore_case);

my %opts;

sub usage {
	print STDERR for
	"Usage: urlencode [-AdprxX] [string]\n",
	"\n",
	"    -A    encode for mq\n",
	"    -d    decode\n",
	"    -D    decode + as space\n",
	"    -o    oct-encode (\\123)\n",
	"    -p    encode full path (allowing slashes)\n",
	"    -q    encode quoted-printable\n",
	"    -P    do not encode parentheses\n",
	"    -r    do not print newline\n",
	"    -x    hex-encode (\\xAB)\n",
	"    -X    XML-escape\n";
	exit;
}

sub decode {
	if ($opts{format_QP}) {
		s/=\n//sg;
		s/=([A-F0-9]{2})/pack('C', hex($1))/seg;
	} else {
		if ($opts{format_mq}) {
			s/^://;
		}
		s/%([A-Fa-f0-9]{2})/pack('C', hex($1))/seg;
		if ($opts{decode_plus}) {
			s/\+/ /g;
		}
		if ($opts{safe_filename}) {
			s!/!⁄!g;
			s!<!‹!g;
			s!>!›!g;
			s!"!'!g;
			s![:?*\\]!_!g;
		}
	}
}

sub encode {
	if ($opts{format_mq}) {
		s/[\x00-\x1F %]/sprintf("%%%02X", ord($&))/seg;
		s/^$|^:/:$&/;
	} elsif ($opts{format_c_hex}) {
		s/[^A-Za-z0-9_. \/-]/sprintf("\\x%02X", ord($&))/seg;
	} elsif ($opts{format_c_octal}) {
		s/[^A-Za-z0-9_. \/-]/sprintf("\\%03o", ord($&))/seg;
	} elsif ($opts{format_url_with_slashes}) {
		s/[^\/A-Za-z0-9_.!~*'-]/sprintf("%%%02X", ord($&))/seg;
	} elsif ($opts{format_QP}) {
		s/[^\x21-\x3C\x3E-\x7E]/sprintf("=%02X", ord($&))/seg;
	} elsif ($opts{format_xml}) {
		s/&/&amp;/g;
		s/</&lt;/g;
		s/>/&gt;/g;
		s/"/&quot;/g;
	} else {
		s/[^A-Za-z0-9_.!~*'()-]/sprintf("%%%02X", ord($&))/seg;
		if (!$opts{format_url_with_parens}) {
			s/[()]/sprintf("%%%02X", ord($&))/seg;
		}
	}
}

sub process {
	local $_ = shift;
	if ($opts{decode}) {
		decode($_);
	} else {
		encode($_);
	}
	print $_;
	print "\n" unless $opts{raw_newline};
}

GetOptions(
	"A|mq" => \$opts{format_mq},
	"d|decode" => \$opts{decode},
	"D|decode-plus" => \$opts{decode_plus},
	"o|octal" => \$opts{format_c_octal},
	"p|path" => \$opts{format_url_with_slashes},
	"P|parens" => \$opts{format_url_with_parens},
	"q|quoted-printable" => \$opts{format_QP},
	"r|raw!" => \$opts{raw_newline},
	"S|safe-filename" => \$opts{safe_filename},
	"x|hex" => \$opts{format_c_hex},
	"X|xml" => \$opts{format_xml},
) || usage();

$opts{decode} ||= $opts{decode_plus};

if (scalar @ARGV) {
	process($_) for @ARGV;
} else {
	if ($opts{decode} && $opts{format_QP}) {
		$_ = do { $/ = undef; <STDIN> };
		decode($_);
		print $_;
	} else {
		while (<STDIN>) {
			chomp unless $opts{raw_newline};
			process($_);
		}
	}
}

#!/usr/bin/env bash
# testrad -- automates RADIUS testing between domains

. lib.bash || exit

lib_config[opt_width]=24

usage() {
	echo "Usage: $progname PROFILE [via SERVER] [options]"
	echo ""
	echo "Server:"
	echo_opt "via SERVER" "Use given server config block"
	echo_opt "host HOSTNAME" "Set RADIUS server address"
	echo_opt "port PORT" "Set RADIUS auth port"
	echo_opt "secret SECRET" "Set RADIUS secret"
	echo ""
	echo "Mechanism:"
	echo_opt "eap|phase1 MECH" "Tunnel inside an EAP mechanism (peap, tls, ttls)"
	echo_opt "mech|phase2 MECH" "Set the main mechanism (pap, mschap, gtc)"
	echo ""
	echo "Outer identity:"
	echo_opt "anon" "Use '@realm' as outer (anonymous) identity"
	echo_opt "outer[-user] ..." "Set outer (anonymous) identity"
	echo ""
	echo "Inner identity:"
	echo_opt "user ..." "Set main (inner) username"
	echo_opt "pass ..." "Set main (inner) password"
	echo_opt "[tls-]cert PATH" "Set client-auth certificate for EAP-TLS"
	echo_opt "[tls-]key PATH" "Set client-auth private key for EAP-TLS"
	echo ""
	echo "Server verification:"
	echo_opt "[tls-]ca PATH" "Verify server against given CA"
	echo_opt "[tls-]ca default" "Verify server against system CAs"
	echo_opt "subject-match ..." "Check server certificate subject [deprecated!]"
	echo_opt "altsubject-match ..." "Check server certificate SAN [deprecated!]"
	echo_opt "domain-match ..." "Check server certificate domain (CN or SAN)"
	echo_opt "domain-suffix-match ..." "Check server certificate domain (CN or SAN)"
	echo ""
	echo "Phase 1 TLS options:"
	echo_opt "tls no-v1.2" "Disable TLS v1.2 (for broken servers)"
	echo_opt "tls no-v1.1" "Disable TLS v1.1 (for really broken servers)"
	echo_opt "tls no-v1.0" "Disable TLS v1.0 (for epicly broken servers)"
	echo_opt "tls ..." "Manually add a phase1=\"...\" option"
	echo ""
	echo "Miscellaneous:"
	echo_opt "show-config" "Dump generated eapol_test config and exit"
	echo_opt "-o ..." "Manually add a config setting for eapol_test"
	echo_opt "-O PATH" "Save phase 1 TLS certificate chain to file"
	echo_opt "-x PATH" "Use a different eapol_test executable"
	echo ""
	echo "Many options translate directly to wpa_supplicant settings."
	echo "Both GNU \"--opt ARG\" and iproute \"opt ARG\" formats are accepted."
}

declare -- server port secret eap mech phase2
declare -- identity outer_id password
declare -- tls_cert tls_key tls_ca save_chain
declare -a tls_opts phase1_opts
declare -a ecfg_full ecfg_extra
declare -A ecfg_values ecfg_seen

eapol_bin="eapol_test"

# parse config

lib::find_file config_file= ~/lib/testrad.conf.sh config:testrad.conf.sh

debug "loading profiles from '$config_file'"

. "$config_file" || die "could not load configuration"

# parse arguments

declare -- profile=
declare -i depth=0

load_conf() {
	local type=$1 name=${2//-/_}
	local var="${type}_${name}[@]"

	set -- "${!var}"

	if (( ! $# )); then
		err "no $type '$name' found"
		return
	elif (( depth > 5 )); then
		die "profile recursion limit exceeded"
	else
		(( ++depth ))
		debug "($depth) parsing $var"
		parse_args "$@"
		debug "($depth) finished $var"
		(( depth-- ))
	fi
}

parse_args() {
	debug "current load type '$type', name '$name'"
	while (( $# )); do
		if [[ $1 == --help ]]; then
			usage; exit
		elif [[ ! $profile ]]; then
			debug "accepting first arg '$1' as profile name"
			profile=$1
			load_conf profile "$profile"
		else
			debug "parsing arg '$1', next '$2'"
			case ${1#--} in
			# runtime & misc eapol_test options
			-o)
				ecfg_extra+=("$2"); shift;;
			-O)
				save_chain=$2; shift;;
			-x)
				eapol_bin=$2; shift;;
			help)
				usage; exit;;
			show-config)
				dump_config=1;;
			# RADIUS server
			inherit)
				if [[ $type == server ]]; then
					die "cannot nest profile in server configuration"
				fi
				load_conf profile "$2"; shift;;
			via)
				load_conf server "$2"; shift;;
			host)
				server=$2; shift;;
			port)
				port=$2; shift;;
			secret)
				secret=$2; shift;;
			# mechanism choice
			eap|inside|phase1)
				eap=$2; shift;;
			mech|using|phase2)
				mech=$2; shift;;
			# main (inner) identity
			user|login|inner-user|inner-login)
				identity=$2; : ${password:="-"}; shift;;
			pass)
				password=$2; shift;;
			cert|tls-cert)
				tls_cert=$2; shift;;
			key|tls-key)
				tls_key=$2; shift;;
			ca|tls-ca|ca-cert)
				tls_ca=$2; shift;;
			tls)
				tls_opts+=("$2"); shift;;
			# anonymous (outer) identity
			anon)
				outer_id=@;;
			outer|outer-user|outer-login)
				outer_id=$2; shift;;
			# misc eapol options
			subject-match)
				ecfg_extra+=("subject_match=\"$2\""); shift;;
			altsubject-match)
				ecfg_extra+=("altsubject_match=\"$2\""); shift;;
			domain-match)
				ecfg_extra+=("domain_match=\"$2\""); shift;;
			domain-suffix-match)
				ecfg_extra+=("domain_suffix_match=\"$2\""); shift;;
			# etc.
			*)
				err "bad arg: \"$1\"";;
			esac
		fi
		shift
	done
}

parse_args "$@"

if [[ $profile && ! $server ]]; then
	debug "server not set, trying to load '$profile' based on profile"
	if [[ -v "server_$profile" ]]; then
		load_conf server "$profile"
	else
		err "server for profile '$profile' not configured (use 'via â€¦')"
	fi
fi

# check for necessary tools

have 'radtest' || err "missing 'radtest' binary"
have "$eapol_bin" || err "missing '$eapol_bin' binary"

(( !errors )) || exit

# check server parameters

IPV4_RE='^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$'

if [[ ! $server ]]; then
	die "missing RADIUS server address"
elif [[ $server == *:*:* ]]; then
	die "RADIUS over IPv6 is not yet supported by eapol_test"
elif [[ $server == *:* ]]; then
	die "invalid server name (use the 'port' option)"
elif ! [[ $server =~ $IPV4_RE ]]; then
	if have name2addr; then
		server_ip=$(name2addr -4 "$server")
	elif have getent; then
		server_ip=$(getent ahostsv4 "$server" | awk '{print $1}' | head -1)
	else
		die "missing 'name2addr' binary required for DNS resolution"
	fi
	if [[ $server_ip ]]; then
		debug "resolved '$server' to '$server_ip'"
		server=$server_ip
	else
		die "could not resolve RADIUS server '$server'"
	fi
fi

[[ $port ]] || port=1812

[[ $secret ]] || err "missing RADIUS secret"

(( !errors )) || exit

# check client parameters

if [[ $password == "-" ]]; then
	read -s -p "password for '$identity': " password; echo
fi

[[ $identity ]]	|| err "missing username"
[[ $outer_id ]]	|| outer_id=$identity
[[ $password ]]	|| err "missing password"

if [[ $outer_id == "@" ]]; then
	outer_id+=${identity#*@}
fi

eap=${eap^^}

case $mech in
	# only set a default for radtest, let eapol_test autoguess
	'')		mech='pap';;
	# direct translation to eapol_test phase2
	'pap')		phase2='PAP';;
	'chap')		phase2='CHAP';;
	'mschap')	phase2='MSCHAP';;
	'mschapv2')	phase2='MSCHAPV2';;
	'eap-gtc')	phase2='EAP-GTC';;
	'eap-md5')	phase2='EAP-MD5';;
	'eap-mschapv2')	phase2='EAP-MSCHAPV2';;
	# in case I ever try to make this nonsense work
	'eap-pap')	die "PAP is not an EAP mechanism";;
	'eap-chap')	die "CHAP is not an EAP mechanism";;
	'eap-mschap')	die "EAP-MSCHAP is actually EAP-MSCHAPV2";;
	*)		err "unknown mechanism '$mech'";;
esac

if [[ ! $eap && $mech != @(pap|chap|mschap|eap-md5) ]]; then
	die "radtest does not support the '$mech' mechanism"
fi

if [[ $tls_ca == default ]]; then
	tls_ca=/etc/ssl/certs/ca-certificates.crt
fi

if [[ $tls_ca && ! -f $tls_ca ]]; then
	err "CA file '$tls_ca' does not exist"
fi

if [[ $eap == TLS ]]; then
	if [[ $tls_key == same ]]; then
		tls_key=$tls_cert
	fi

	if [[ ! $tls_cert ]]; then
		err "missing certificate for EAP-$eap ('cert' option)"
	elif [[ ! -f $tls_cert ]]; then
		err "certificate '$tls_cert' does not exist"
	fi

	if [[ ! $tls_key ]]; then
		err "missing private key for EAP-$eap ('key' option)"
	elif [[ ! -f $tls_key ]]; then
		err "key file '$tls_key' does not exist"
	fi
fi

if [[ $eap == @(PEAP|TLS|TTLS) ]]; then
	for opt in "${tls_opts[@]}"; do
		case $opt in
		'no-v1.0')	phase1_opts+=("tls_disable_tlsv1_0=1");;
		'no-v1.1')	phase1_opts+=("tls_disable_tlsv1_1=1");;
		'no-v1.2')	phase1_opts+=("tls_disable_tlsv1_2=1");;
		'tls_'*)	phase1_opts+=("$opt");;
		*)		err "unknown TLS option '$opt'";;
		esac
	done
fi

(( ! errors )) || exit

# do the test

log "account: \"$identity\""
debug "password: \"$password\""
log "server: $server"
debug "secret: \"$secret\""

if [[ $eap && $eap != NONE ]]; then
	# base options
	ecfg_full=(
		"ssid=\"eduroam\""
		"key_mgmt=WPA-EAP"
		"eap=$eap"
	)
	if [[ ${phase1_opts[*]} ]]; then
		ecfg_full+=("phase1=\"${phase1_opts[*]}\"")
	fi

	# phase 2
	if [[ $eap == PEAP ]]; then
		if [[ $phase2 == EAP-* ]]; then
			ecfg_full+=("phase2=\"auth=${phase2#EAP-}\"")
		elif [[ $phase2 ]]; then
			err "EAP-$eap can only transport EAP methods"
		fi
	elif [[ $eap == TTLS ]]; then
		if [[ $phase2 == EAP-* ]]; then
			ecfg_full+=("phase2=\"autheap=${phase2#EAP-}\"")
		elif [[ $phase2 ]]; then
			ecfg_full+=("phase2=\"auth=${phase2}\"")
		fi
	fi

	# credentials
	ecfg_full+=("identity=\"$identity\"")
	ecfg_full+=("password=\"$password\"")
	if [[ $outer_id ]]; then
		ecfg_full+=("anonymous_identity=\"$outer_id\"")
	fi
	if [[ $tls_ca ]]; then
		ecfg_full+=("ca_cert=\"$tls_ca\"")
	fi
	if [[ $tls_cert ]]; then
		ecfg_full+=("client_cert=\"$tls_cert\"")
	fi
	if [[ $tls_key ]]; then
		ecfg_full+=("private_key=\"$tls_key\"")
	fi

	# user-supplied settings
	for opt in "${ecfg_extra[@]}"; do
		case $opt in
		# disallowed settings
		'anonymous_identity='*)
			err "'$opt': use 'outer-user ...' to set the anonymous identity";;
		'eap='*)
			err "'$opt': use 'eap ...' to set the outer EAP method";;
		'identity='*)
			err "'$opt': use 'user ...' to set the auth identity";;
		'phase2='*)
			err "'$opt': use 'phase2 ...' to set the inner EAP method";;
		# magic values
		'domain_suffix_match="@"')
			debug "expanding '$opt'"
			if [[ $identity == *@* ]]; then
				opt="${opt%=*}=\"${identity#*@}\""
				debug "... expanded to '$opt'"
			else
				err "cannot expand '$opt' from identity '$identity'"
			fi
			;;&
		# rest
		?*'='*)
			ecfg_full+=("$opt");;
		*)
			err "supplicant option '$opt' given without value";;
		esac
	done
	(( ! errors )) || exit

	# if option given multiple times, the last value takes priority
	for opt in "${ecfg_full[@]}"; do
		k=${opt%%=*}
		v=${opt#*=}
		ecfg_values["$k"]=$v
	done

	log "mechanism: EAP-$eap (outer), ${phase2:-default} (inner)"
	if [[ "$outer_id" != "$identity" ]]; then
		log "anonymous identity: \"$outer_id\""
	fi

	# generate the eapol_test config
	wd=$(mktemp -d /tmp/testrad.XXXXXXXX)
	conf="$wd/eapol_test.conf"
	{
		echo "network={"
		for opt in "${ecfg_full[@]}"; do
			k=${opt%%=*}
			v=${ecfg_values["$k"]}
			if (( ecfg_seen["$k"]++ )); then
				continue
			fi
			if [[ ! $v || $v == \"\" ]]; then
				continue
			fi
			printf "\t%s=%s\n" "$k" "$v"
		done
		echo "}"
	} > "$conf"
	(( ! errors )) || exit

	cmd=($eapol_bin -c "$conf" -a "$server" -p "$port" -s "$secret" -t 5
			-M "22:44:66:42:42:42"
			-C "testrad+eapol_test (${EMAIL:-$USERNAME@$HOSTNAME})")

	if [[ $save_chain ]]; then
		cmd+=(-o "$save_chain")
	fi

	if (( dump_config )); then
		notice "dumping generated config and exiting"
		cmd=(cat "$conf")
	fi
else
	log "mechanism: $phase2 (direct)"
	if [[ "$outer_id" != "$identity" ]]; then
		die "anonymous identity \"$outer_id\" not supported without EAP"
	fi
	cmd=(radtest -t "$mech" "$identity" "$password" "$server:$port" 0 "$secret")
fi

echo "+ ${cmd[*]}"

if "${cmd[@]}"; then
	r=0
	log "test successful"
else
	r=$?
	err "test failed ($cmd returned $r)"
fi

if [[ -s $save_chain ]]; then
	log "server certificate chain saved to '$save_chain'"
elif [[ $save_chain ]]; then
	err "did not obtain server certificate chain"
fi

if [[ $wd == /tmp/testrad.* ]]; then
	rm -rf "$wd"
fi

exit $r

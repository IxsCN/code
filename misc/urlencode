#!/usr/bin/env perl
# vim: ts=4:sw=4:noet
use warnings;
use strict;
use Getopt::Long qw(:config bundling no_ignore_case);

my %opts;

sub usage {
	print STDERR for
	"Usage: urlencode [-AdprxX] [string]\n",
	"\n",
	"    -A    encode for mq\n",
	"    -d    decode\n",
	"    -D    decode + as space\n",
	"    -o    oct-encode (\\123)\n",
	"    -p    encode full path (allowing slashes)\n",
	"    -L    encode LDAP DN (allowing =)\n",
	"    -q    encode quoted-printable\n",
	"    -P    do not encode parentheses\n",
	"    -r    do not print newline\n",
	"    -x    hex-encode (\\xAB)\n",
	"    -X    XML-escape\n";
	exit;
}

sub decode {
	my ($buf) = @_;

	for ($buf) {
		if ($opts{format_QP}) {
			s/=\n//gs;
			s/=([A-F0-9]{2})/pack('C', hex($1))/gse;
		} else {
			if ($opts{format_mq}) {
				s/^://;
			}
			s/%([A-Fa-f0-9]{2})/pack('C', hex($1))/gse;
			if ($opts{decode_plus}) {
				s/\+/ /g;
			}
		}
		if ($opts{safe_filename}) {
			s!/!⁄!g;
			s!<!‹!g;
			s!>!›!g;
			s!"!'!g;
			s![:?*\\]!_!g;
		}
	}

	return $buf;
}

sub encode {
	my ($buf) = @_;

	for ($buf) {
		if ($opts{format_mq}) {
			s/[\x00-\x1F %]/sprintf("%%%02X", ord($&))/gse;
			s/^$|^:/:$&/;
		} elsif ($opts{format_QP}) {
			s/[^\x21-\x3C\x3E-\x7E]/sprintf("=%02X", ord($&))/gse;
		} elsif ($opts{format_c_hex}) {
			s/[^A-Za-z0-9_. \/-]/sprintf("\\x%02X", ord($&))/gse;
		} elsif ($opts{format_c_octal}) {
			s/[^A-Za-z0-9_. \/-]/sprintf("\\%03o", ord($&))/gse;
		} elsif ($opts{format_xml}) {
			s/&/&amp;/g;
			s/</&lt;/g;
			s/>/&gt;/g;
			s/"/&quot;/g;
		} else {
			s/[^\/A-Za-z0-9_.!~*',=()-]/sprintf("%%%02X", ord($&))/gse;
			if (!$opts{format_ldap_dn}) {
				s/[,=]/sprintf("%%%02X", ord($&))/gse;
			}
			if (!$opts{format_url_with_slashes}) {
				s/\//sprintf("%%%02X", ord($&))/gse;
			}
			if (!$opts{format_url_with_parens}) {
				s/[()]/sprintf("%%%02X", ord($&))/gse;
			}
		}
	}

	return $buf;
}

sub process {
	my ($buf) = @_;

	if ($opts{decode}) {
		print decode($buf);
	} else {
		print encode($buf);
	}

	print "\n" unless $opts{raw_newline};
}

GetOptions(
	"d|decode" => \$opts{decode},
	"D|decode-plus" => \$opts{decode_plus},
	"o|octal" => \$opts{format_c_octal},
	"p|path" => \$opts{format_url_with_slashes},
	"P|parens" => \$opts{format_url_with_parens},
	"q|quoted-printable" => \$opts{format_QP},
	"ldap-dn" => \$opts{format_ldap_dn},
	"mq" => \$opts{format_mq},
	"r|raw!" => \$opts{raw_newline},
	"S|safe-filename" => \$opts{safe_filename},
	"x|hex" => \$opts{format_c_hex},
	"X|xml" => \$opts{format_xml},
) || usage();

$opts{decode} ||= $opts{decode_plus};

if (scalar @ARGV) {
	process($_) for @ARGV;
} else {
	if ($opts{decode} && $opts{format_QP}) {
		my $buf = do { $/ = undef; <STDIN> };
		print decode($buf);
	} else {
		while (<STDIN>) {
			chomp($_) unless $opts{raw_newline};
			process($_);
		}
	}
}

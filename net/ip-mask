#!/usr/bin/env python3
import sys
from ipaddress import *
from nullroute.core import *

IPV6_MCAST_SCOPES = {
    0x0: "reserved",
    0x1: "interface-local",
    0x2: "link-local",
    0x4: "admin-local",
    0x5: "site-local",
    0x8: "organization-local",
    0xe: "global",
    0xf: "reserved",
}

IPV4_MCAST_BLOCKS = [
    ("224.0.0.0/24", "subnet-local", "Local Network Control Block (IANA)"),
    ("224.0.1.0/24", "global", "Internetwork Control Block (IANA)"),
    ("224.0.0.0/16", "global", "ad-hoc (IANA)"),
    ("224.1.0.0/16", "reserved", "IANA (RFC 5771)"),
    ("224.2.0.0/16", "?", "SDP/SAP (RFC 5771)"),
    ("224.3.0.0/16", "global", "ad-hoc (IANA)"),
    ("224.4.0.0/16", "global", "ad-hoc (IANA)"),
    ("232.0.0.0/8", "source-specific", None),
    ("233.252.0.0/14", "global", "ad-hoc (IANA)"),
    ("233.0.0.0/8", "global", "AS-based/GLOP (RFC 3180)"),
    ("234.0.0.0/8", "global", "unicast-prefix-based (RFC 6034)"),
    ("239.0.0.0/8", "organization", "RFC 1884/RFC 2365"),
    ("224.0.0.0/4", "reserved", "IANA (RFC 5771)"),
]

IPV4_MCAST_GROUPS = {
    # 224.0.0.0/24
    "224.0.0.1":        "All Nodes",
    "224.0.0.2":        "All Routers",
    "224.0.0.5":        "OSPF all routers",
    "224.0.0.6":        "OSPF designated routers",
    "224.0.0.9":        "RIP v2 routers",
    "224.0.0.13":       "PIM v2 routers",
    "224.0.0.19":       "IS-IS over IP",
    "224.0.0.20":       "IS-IS over IP",
    "224.0.0.21":       "IS-IS over IP",
    "224.0.0.22":       "IGMP v3",
    "224.0.0.102":      "HSRP v2 & GLBP load-balancing",
    "224.0.0.251":      "mDNS (Multicast DNS)",
    "224.0.0.252":      "LLMNR (Link-local multicast name resolution)",
    # 224.0.1.0/24
    "224.0.1.1":        "NTP (Network Time Protocol)",
    "224.0.1.3":        "rwhod",
    "224.0.1.20":       "(any private experiment)",
    "224.0.1.60":       "HP device discovery",
    # 226/8 reserved
    "226.178.217.5":    "possibly Spybot Search&Destroy",
    # 232.0.0.0/8
    # 233.0.0.0/8
    "233.89.188.1":     "Ubiquiti discovery",
    # 234.0.0.0/8
    # 239.0.0.0/8
    "239.192.0.0":      "BitTorrent Sync LPD",
    "239.192.152.143":  "BitTorrent LPD (Local Peer Discovery)",
    "239.255.255.250":  "SSDP (UPnP)",
}

IPV6_MCAST_GROUPS = {
    "ff02::1": "All Nodes",
    "ff02::2": "All Routers",
    "ff02::c": "SSDP",
    "ff02::d": "All PIM routers",
    "ff02::f": "UPnP",
    "ff02::16": "MLD v2",
    "ff02::fb": "mDNS (Multicast DNS)",
}

def nprint(k, *v):
    width = 12
    print("\033[33m%*s\033[m" % (width, k), *v)

def ipv4_mcast_describe(addr):
    for mask, scope, desc in IPV4_MCAST_BLOCKS:
        if addr in ip_network(mask):
            return mask, scope, desc

def ipv6_is_isatap(addr):
    if addr.version != 6:
        return False
    return (addr.packed[8:12] in {b'\x00\x00\x5e\xfe', b'\x02\x00\x5e\xfe'})

def ipv6_is_eui48(addr):
    if addr.version != 6:
        return False
    return (addr.packed[11:13] == b'\xff\xfe')

def ipv6_get_eui48(addr):
    mac = list(addr.packed[8:11] + addr.packed[13:])
    mac[0] ^= 2
    return ":".join(["%02x" % n for n in mac])

def ipv6_get_v4mapped(addr, at=12):
    if addr.version == 4:
        return addr
    return IPv4Address(addr.packed[at:at+4])

def addr2props(addr):
    kind = "unknown"
    misc = []
    if addr.version == 6:
        if addr.is_loopback:
            kind = "loopback"
        elif addr.is_unspecified:
            kind = "unspecified"
        elif addr.teredo:
            kind = "global (Teredo)"
            misc.append(("relay host", addr.teredo[0]))
            misc.append(("v4 address", addr.teredo[1]))
        elif addr.sixtofour:
            kind = "global (6to4)"
            misc.append(("v4 address", addr.sixtofour))
            if ipv6_is_isatap(addr):
                misc.append(("ISATAP v4", ipv6_get_v4mapped(addr)))
        elif addr.ipv4_mapped:
            kind = "IPv4-mapped"
            misc.append(("v4 address", addr.ipv4_mapped))
        elif addr in IPv6Network("::/96"):
            kind = "IPv4-compatible"
            misc.append(("v4 address", ipv6_get_v4mapped(addr)))
        elif addr in IPv6Network("64:ff9b::/96"):
            kind = "NAT64"
            misc.append(("v4 address", ipv6_get_v4mapped(addr)))
        elif addr.is_link_local:
            kind = "link-local"
            if ipv6_is_isatap(addr):
                misc.append(("ISATAP v4", ipv6_get_v4mapped(addr)))
        elif addr.is_site_local:
            kind = "site-local"
        elif addr.is_multicast:
            kind = "multicast"
            flags = (addr.packed[1] >> 4) & 0xF
            scope = addr.packed[1] & 0xF
            scope = IPV6_MCAST_SCOPES.get(scope, "invalid scope")
            misc.append(("scope", scope))
            group_name = IPV6_MCAST_GROUPS.get(str(addr))
            if group_name:
                misc.append(("usage", group_name))
        elif addr in IPv6Network("fc00::/7"):
            kind = "unique local address"
        elif addr.is_reserved:
            kind = "reserved"
        else:
            kind = "global"
            if ipv6_is_eui48(addr):
                mac = ipv6_get_eui48(addr)
                misc.append(("MAC address", mac))
            if ipv6_is_isatap(addr):
                misc.append(("ISATAP v4", ipv6_get_v4mapped(addr)))
    elif addr.version == 4:
        if addr in ip_network("224.0.0.0/4"):
            kind = "multicast"

        group_name = IPV4_MCAST_GROUPS.get(str(addr))
        if group_name:
            misc.append(("usage", group_name))

        _ = ipv4_mcast_describe(addr)
        if _:
            range, scope, desc = _
            misc.append(("scope", scope))
            misc.append(("range", "%s - %s" % (range, desc)))

        if addr in ip_network("233.0.0.0/8"):
            as_num = (addr.packed[1] << 8) | addr.packed[2]
            misc.append(("seed", "AS %d" % as_num))
        elif addr in ip_network("234.0.0.0/8"):
            unicast = ip_address( (addr.packed[1] << 24) \
                                | (addr.packed[2] << 16) \
                                | (addr.packed[3] <<  8) )
            misc.append(("seed", unicast))

    return kind, misc

def show_addr(addr):
    nprint("address", addr)
    if addr.version == 6:
        nprint("->", addr.exploded)
    kind, misc = addr2props(addr)
    nprint("type", kind)
    for k, v in misc:
        nprint(k, v)

def show_net(net):
    nprint("network", net)
    if addr.version == 4:
        nprint("netmask", net.netmask, "(%d addresses)" % net.num_addresses)
    else:
        nprint("netmask", net.netmask.exploded)
    nprint("first addr", net.network_address.exploded)
    nprint("last addr", net.broadcast_address.exploded)
    next_net = ip_network("%s/%s" % (net.broadcast_address + 1, net.prefixlen))
    nprint("next net", next_net)

i = -1
for i, arg in enumerate(sys.argv[1:]):
    if i > 0:
        print()
    try:
        if arg.startswith("/"):
            plen = int(arg[1:])
            if plen < 0:
                Core.die("prefix length must be positive")
            elif plen > 128:
                Core.die("prefix length too large for any family")

            nprint("prefix", "/%d" % plen)
            if plen <= 32:
                net = ip_network("0.0.0.0/%d" % plen)
                nprint("v4 netmask", net.netmask, "(%d addresses)" % net.num_addresses)
            net = ip_network("::/%d" % plen)
            nprint("v6 netmask", net.netmask.exploded)
        elif "/" in arg:
            addr = ip_interface(arg)
            show_addr(addr)
            print()
            show_net(addr.network)
        else:
            addr = ip_address(arg)
            if addr.version == 4 and addr._is_valid_netmask(arg):
                net = ip_network("0.0.0.0/%s" % arg)
                nprint("netmask", net.netmask)
                nprint("prefix", "/%d" % net.prefixlen)
                nprint("size", net.num_addresses)
            else:
                show_addr(addr)
    except ValueError as e:
        Core.die(str(e))
if i < 0:
    Core.die("not enough arguments")
